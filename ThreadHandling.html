<!DOCTYPE HTML> 
	<html><head>
	<meta charset='utf-8' />
	<title>Threads in Java</title> 
<meta name="viewport" content="width=device-width, initial-scale=1">  
<script type="text/javascript" src="according.js"></script>
<link rel="stylesheet" type="text/css" href="descriptivestyle.css"> 
 
	 </head>
	 
	 
	 </head><body  > 
		 <h1 class="heading">Threads in Java</h1><hr color='#eee'>
<div class="question">1. What is a thread? How do you create a thread in Java?</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >A thread is a path of program execution.<br><br>All Java programs at least one thread called main thread which is started by JVM.<br><br>A thread can be created by extending thread class or by implementing runnable interface. <br><br>e.g.<br><br>package helloworld;<br><br>public class ThreadTest extends Thread {<br><br>	int m;<br><br>	</p><p>Override<br>	public void run() {<br><br>		super.run();<br>		for (int i = 0; i &lt; 100; i++) {<br>			System.out.println("m is " + m);<br>			System.out.println("My name is " + this.toString());<br>			synchronized (this) {<br>				try {<br>					this.wait(100);<br>				} catch (InterruptedException e) {<br>					// TODO Auto-generated catch block<br>					e.printStackTrace();<br>				}<br>			}<br>			m++;<br>		}<br>	}<br><br>}<br><br>The program which creates these threads is<br>public class ThreadTestMain {<br>	public static void main(String args[]) {<br>		ThreadTest t1,t2,t3;<br>		t1 = new ThreadTest();<br>		t2 = new ThreadTest();<br>		t3 = new ThreadTest();<br>		<br>		t1.start();<br>		t2.start();<br>		t3.start();<br>	}<br><br>}<br><br>And to create a thread using runnable interface, you can use a code like this<br><br>  public class IntrTest implements Runnable {<br>	</p></div><hr color='#eee'>
</div><div class="question"><p>2. What is the differences between a thread and a process?</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >Both processes and threads are independent sequences of execution. The difference is that threads (of the same process) run in a shared memory space, while processes run in separate memory spaces.<br><br> A process can have multiple threads running in it. All threads of a process share its virtual address space and system resources.  <br><br>Since the threads of a process share the same memory, synchronizing the access to the shared data between threads is very important. <br><br>There are the following differences between the process and thread.<br><br>    A Program in the execution is called the process whereas; A thread is a subset of the process<br>    Processes are independent whereas threads are the subset of process.<br>    Process have different address space in memory, while threads contain a shared address space.<br>    Context switching is faster between the threads as compared to processes.<br>    Inter-process communication is slower and expensive than inter-thread communication.<br>    Any change in Parent process doesn't affect the child process whereas changes in parent thread can affect the child thread.<br></p></div><hr color='#eee'>
</div><div class="question">3. Explain life cycle of a thread. </p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >The java.lang.Thread class contains a static State enum – which defines its potential states. During any given point of time, the thread can only be in one of these states:<br><br>    NEW – newly created thread that has not yet started the execution<br>    RUNNABLE – either running or ready for execution but it's waiting for resource allocation<br>    BLOCKED – waiting to acquire a monitor lock to enter or re-enter a synchronized block/method<br>    WAITING – waiting for some other thread to perform a particular action without any time limit<br>    TIMED_WAITING – waiting for some other thread to perform a specific action for a specified period<br>    TERMINATED – has completed its execution<br></p></div><hr color='#eee'>
</div><div class="question">4. What are differences between Sleep and wait in java?
</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >sleep is a static method which will pause the thread. It can be called from any context. <br><br>But wait is an instance method and it can be called only in synchronized block. It releases the lock on the object so that other threads can acquire the lock. <br><br>When we use the sleep() method, a thread gets started after a specified time interval, unless it is interrupted.<br><br>For wait(), we can wake the thread by calling either the notify() or notifyAll() methods on the monitor that is being waited on.<br><br>Use notifyAll() instead of notify() when you want to wake all threads that are in the waiting state. Similarly to the wait() method itself, notify(), and notifyAll() have to be called from the synchronized context.</p></div><hr color='#eee'>
</div><div class="question">5. What are the two ways in which you can create a thread? Give examples.</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >A thread can be created by either implementing runnable interface or subclassing thread class.<br><br>Runnable interface has just one method run(). <br><br>In both cases, you need to override run() method.<br><br>And to start the thread of execution, you have to call start() method in both cases. <br><br>e.g.<br><br>public class Run implements Runnable {<br><br>	</p><p>Override<br>	public void run() {<br>		 System.out.println("this is run method");<br>		<br>	}<br>	<br>	public static void main(String args[]) {<br>		new Thread(new Run()).start();<br>	}<br><br>}<br><br>Here is the example of subclassing Thread class<br><br>public class ThreadTest  extends Thread{<br>	public void run() {<br>		System.out.println("Hello from run of thread ");<br>	}<br>	public static void main(String args[]) {<br>		ThreadTest th = new ThreadTest();<br>		th.start();<br>	}<br>	 <br>}</p></div><hr color='#eee'>
</div><div class="question">6. What are daemon threads in Java? How are they different from user threads?</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >Daemon threads are low priority threads created by system. e.g. Garbage collector. These threads help the user threads and they run in the background. When all the user threads are completed, JVM stops the daemon threads.<br><br>A thread can be made as daemon thread by using the method<br><br>setDaemon(boolean )<br><br>setDaemon can only be called, before the thread is started. If it is called after the thread starts running, there will be a illegal state exception.<br><br>Daemon thread inherits its daemon state from the parent. If parent is a daemon, then child will also be daemon.<br><br>To check if a thread is daemon or not, we can use isDaemon() method. </p></div><hr color='#eee'>
</div><div class="question">7. What is multithreading?</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >Multithreading is a process of executing multiple threads simultaneously. Multithreading is used to obtain the multitasking. It consumes less memory and gives the fast and efficient performance. Its main advantages are:<br><br>    Threads share the same address space.<br>    The thread is lightweight.<br>    The cost of communication between the processes is low.</p></div><hr color='#eee'>
</div><div class="question">8. What is thread synchronization? Explain with examples.</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >Threads communicate primarily by sharing access to fields and the objects reference fields refer to.  But such communication may produce  thread interference and memory consistency errors. <br><br>The tool needed to prevent these errors is synchronization.<br> <br>Let us say we have a counter class with increment and decrement methods - to increase and decrease the counter by 1. Now if these methods are accessed by multiple threads, the methods of different threads may overlap - which may result in inconsistent values. <br><br>Thread synchronization is achieved using a synchronized method or a synchronized block. <br><br>Synchronized method: A method is prefixed with the keyword synchronized.<br><br>e.g.<br>     synchronized void increment(){<br>        num++;<br>     }<br>     synchronized void decrement(){<br>        num--;<br>     }<br><br> When one thread is executing a synchronized method for an object, all other threads that invoke synchronized methods for the same object will block (suspend execution) until the first thread is done with the object. When a synchronized method exits, it automatically establishes a happens-before relationship <br><br>Synchronized blocks:<br>Synchronization is built around an internal entity known as the intrinsic lock or monitor lock. <br>Every object has an intrinsic lock associated with it. By convention, a thread that needs exclusive and consistent access to an object's fields has to acquire the object's intrinsic lock before accessing them, and then release the intrinsic lock when it's done with them. A thread is said to own the intrinsic lock between the time it has acquired the lock and released the lock. As long as a thread owns an intrinsic lock, no other thread can acquire the same lock. The other thread will block when it attempts to acquire the lock.<br><br>Unlike synchronized methods, synchronized statements must specify the object that provides the intrinsic lock:<br><br>public void addName(String name) {<br>    synchronized(this) {<br>        lastName = name;<br>        nameCount++;<br>    }<br>    nameList.add(name);<br>}<br><br></p></div><hr color='#eee'>
</div><div class="question">9. What is the difference between multithreading and multiprocessing?</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >Multiprocessing is running multiple processes simultaneously. <br><br>A process is a program under execution. So when we are multiprocessing, we are running many programs simultaneuosly.<br><br>A thread is path of execution within a program. A program can have multiple threads and these threads can run simultaneously - called multithreading. <br><br></p></div><hr color='#eee'>
</div><div class="question">10. Write a program to create two threads - one to display numbers from 1 to 100 and the other to display alphabets. Both these threads must run in a loop. </p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><pre class='courier'>class NumThread extends Thread{
     public void run(){
         for(int i=0;i&lt;100;i++){
             System.out.println(""+(i+1));
             try {
                 Thread.sleep(1000);
             } catch (InterruptedException e) {
                 e.printStackTrace();
             }
         }
     }
}
class AlphaThread extends Thread{
    public void run(){
        for(char ch='a';ch&lt;='z';ch++){
            System.out.println(ch);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

public class TwoThreads {
    public static void main(String args[]){
        NumThread nth = new NumThread();
        nth.start();
        AlphaThread ath = new AlphaThread();
        ath.start();
    }
}
</pre><p>You can create a thread either by subclassing Thread class or by implementing Runnable interface.<br></p></div><hr color='#eee'>
</div><div class="question">11. How can you pause a thread for a specific duration in Java?</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >Thread.sleep(ms)</p></div><hr color='#eee'>
</div><div class="question">12. What is the use of Thread.join() method</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >When we invoke the join() method on a thread, the calling thread goes into a waiting state. It remains in a waiting state until the referenced thread terminates.<br><br>e.g.<br><br>    Thread t = new Thread();<br>     ...<br>    ...<br>    t.join();<br><br>Here the main thread waits for t to terminate.<br><br>To avoid indefinite waiting by join method, we can use overloaded join() with time out period.<br><br>t.join(5000);<br><br>Here the main thread waits for maximum of 5 seconds for t to terminate. 0 as a parameter indicates wait indefinitely.</p></div><hr color='#eee'>
</div><div class="question">13. What does Thread.yield method do?</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >The yield() method causes the currently executing thread object to temporarily pause and allow other threads to execute.<br><br>class A implements Runnable{<br><br>   public void run() {<br>      for (int i = 0; i &lt; 5; i++) {<br>         // yields control to another thread every 5 iterations<br>         if ((i % 5) == 0) {<br>            System.out.println(Thread.currentThread().getName() + "<br>            yielding control...");<br>            /* causes the currently executing thread object to temporarily <br>            pause and allow other threads to execute */<br>            Thread.yield();<br>         }<br>      }<br>}<br><br>Here for each value of i divisible by 5, we are pausing the thread and allowing other thread to execute. </p></div><hr color='#eee'>
</div><div class="question">14. What is the difference between synchronized method and synchronized block?</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >Synchronized blocks:<br>Synchronized blocks in Java are marked with the synchronized keyword. A synchronized block in Java is synchronized on some object. All synchronized blocks synchronized on the same object can only have one thread executing inside them at the same time. All other threads attempting to enter the synchronized block are blocked until the thread inside the synchronized block exits the block. <br><br>Synchronized method:<br><br>When a thread invokes a synchronized method, it automatically acquires the intrinsic lock for that method's object and releases it when the method returns. The lock release occurs even if the return was caused by an uncaught exception.<br><br>If the synchronized method is static method, the thread acquires the intrinsic lock for the Class object associated with the class. Thus access to class's static fields is controlled by a lock  </p></div><hr color='#eee'>
</div><div class="question">15. How do you create a daemon thread in Java?</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >Java has two types of threads - user threads and daemon threads. <br><br>User threads are high-priority threads. The JVM will wait for any user thread to complete its task before terminating it.<br><br>On the other hand, daemon threads are low-priority threads whose only role is to provide services to user threads.<br><br>Since daemon threads are meant to serve user threads and are only needed while user threads are running, they won't prevent the JVM from exiting once all user threads have finished their execution.<br><br>To create a daemon thread, we have to use setDaemon(true)<br><br>e.g.<br>NewThread daemonThread = new NewThread();<br>daemonThread.setDaemon(true);<br>daemonThread.start();</p></div><hr color='#eee'>
</div><div class="question">16. What is a deadlock?</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >Deadlock describes a situation where two or more threads are blocked forever, waiting for each other.  <br><br> A Java multithreaded program may suffer from the deadlock condition because the synchronized keyword causes the executing thread to block while waiting for the lock, or monitor, associated with the specified object. <br><br>e.g.<br><br>public class TestThread {<br>   public static Object Lock1 = new Object();<br>   public static Object Lock2 = new Object();<br>   <br>   public static void main(String args[]) {<br>      ThreadDemo1 T1 = new ThreadDemo1();<br>      ThreadDemo2 T2 = new ThreadDemo2();<br>      T1.start();<br>      T2.start();<br>   }<br>   <br>   private static class ThreadDemo1 extends Thread {<br>      public void run() {<br>         synchronized (Lock1) {<br>            System.out.println("Thread 1: Holding lock 1...");<br>            <br>            try { Thread.sleep(10); }<br>            catch (InterruptedException e) {}<br>            System.out.println("Thread 1: Waiting for lock 2...");<br>            <br>            synchronized (Lock2) {<br>               System.out.println("Thread 1: Holding lock 1 & 2...");<br>            }<br>         }<br>      }<br>   }<br>   private static class ThreadDemo2 extends Thread {<br>      public void run() {<br>         synchronized (Lock2) {<br>            System.out.println("Thread 2: Holding lock 2...");<br>            <br>            try { Thread.sleep(10); }<br>            catch (InterruptedException e) {}<br>            System.out.println("Thread 2: Waiting for lock 1...");<br>            <br>            synchronized (Lock1) {<br>               System.out.println("Thread 2: Holding lock 1 & 2...");<br>            }<br>         }<br>      }<br>   } <br>}<br><br><br>The above code causes a deadlock. Thread 1 holds lock 1 and waits for lock2 to be released and Thread2 holds lock2 and waits for lock1 to be released. </p></div><hr color='#eee'>
</div><div class="question">17. How do you start the execution of a thread?</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >A thread starts execution by calling its start() method. <br><br>It is wrong to call run method instead of start method because run() will start execution of the thread within the current thread whereas </p></div><hr color='#eee'>
</div><div class="question">18. What are the differences between notify and notifyAll methods?</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >The notify() method is used for sending a signal to wake up a single thread in the waiting pool. But notifyAll() method is used for sending a signal to wake up all threads in a waiting pool.</p></div><hr color='#eee'>
</div><div class="question">19. When do you prefer to use Runnable interface instead of extending Thread class?</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >A Thread can be created by using two ways.<br><br>    By extending the Thread class<br>    By implementing the Thread class<br><br>However, the primary differences between both the ways are given below:<br><br>    By extending the Thread class, we cannot extend any other class, as Java does not allow multiple inheritances while implementing the Runnable interface; we can also extend other base class(if required).<br>    By extending the Thread class, each of thread creates the unique object and associates with it while implementing the Runnable interface; multiple threads share the same object<br>    Thread class provides various inbuilt methods such as getPriority(), isAlive and many more while the Runnable interface provides a single method, i.e., run().<br><br><br></p></div><hr color='#eee'>
</div><div class="question">20. What is thread priority? Write a program to create two threads - one with high priority and the other with low priority. The high priority thread must print values from 0 to 10 and low priority thread must print A to Z.</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><pre class='courier'>Each thread has a priority. JVM runs threads with higher priorities over threads with lower priorities. When a thread is created, it will have the same priority as its parent thread.

getPriority() returns the priority of the current thread

setPriority(int pr) will set the priority of the thread. 

Priority values are in the range of Thread.MAX_PRIORITY to Thread.MIN_PRIORITY

class T1 implements Runnable{
    public  void run(){
        while(true){
            for(int i=0;i&lt;100;i++)
               System.out.println(i);
         }
   }
}

class T2 implements Runnable{
    public void run(){
        while(true){
            for(char ch = 'A'; ch&lt;='Z'; ch++)
               System.out.println(ch);
         }
    }
}

class ThrPri{
   public static void main(String args[]){
       Thread thread1 = new Thread(new T1());
       thread1.setPriority(thread1.getPriority()+1);
       Thread thread2 = new Thread(new T2());
       thread2.setPriority(thread2.getPriority()-1);
       thread1.start();
       thread2.start();
    }
}

</pre></div><hr color='#eee'>
</div><div class="question">21. What are pre-emptive scheduling and time slicing?</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >Under preemptive scheduling, the highest priority task executes until it enters the waiting or dead states or a higher priority task comes into existence.<br><br> Under time slicing, a task executes for a predefined slice of time and then reenters the pool of ready tasks. The scheduler then determines which task should execute next, based on priority and other factors. <br><br>But also note that Java does not force a VM to schedule threads in a specific manner or contain a thread scheduler. That implies platform-dependent thread scheduling.</p></div><hr color='#eee'>
</div><div class="question">22. What happens if we call run method instead of start method of a thread?</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >If we call a run method instead of start method of a thread, then a new thread is not created. The run method of thread is executed within the existing thread itself. <br><br>So we must always call start() method of a thread. This will create a thread and start execution of this thread using run method. </p></div><hr color='#eee'>
</div><div class="question">23. What is shutdown hook?</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >Shutdown Hooks are a special construct that allows developers to plug in a piece of code to be executed when the JVM is shutting down. This comes in handy in cases where we need to do special clean up operations in case the VM is shutting down.<br><br>public class ShutDownHook <br>{ <br>    public static void main(String[] args) <br>    { <br>         Runtime.getRuntime().addShutdownHook(new Thread({         <br>            public void run()<br>            {<br>                System.out.println("Shutdown Hook is running !"); <br>             } <br>          }); <br>         System.out.println("Application Terminating ..."); <br>} <br>} <br><br>When we run this code, the shutdown hook will be executed when the JVM finishes execution of main method.<br><br>Please note the following<br>1. The shutdown hook may not get called at all - if OS gives SIGKILL or if there is an internal error which crashes the JVM, the shutdown hook code may not get executed.<br>2. The code of shutdown hook can be stopped in the middle only by using Runtime.halt() method is called.<br>3. There can be multiple shutdown hooks, but their execution order is not pre-determined.<br>4.If we are using Java Security Managers, then the code which performs adding/removing of shutdown hooks need to have the shutdownHooks permission at runtime.<br></p></div><hr color='#eee'>
</div><div class="question">24. Why do we need synchronization of methods?</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >If your code is executing in a multi-threaded environment, you need synchronization for objects, which are shared among multiple threads, to avoid any corruption of state or any kind of unexpected behavior. <br><br>Synchronization in Java will only be needed if a shared object is mutable<br><br>If your shared object is an either read-only or immutable object, then you don't need synchronization, despite running multiple threads.<br></p></div><hr color='#eee'>
</div><div class="question">25. Explain sleep() method of a thread.</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >Sleep method is used to pause the execution of the current thread for a given duration.<br><br>e.g.<br> <br>public class Demo {<br><br>    public static void main(String[] args) throws InterruptedException {         <br>        Thread.sleep(2000);         <br>    }<br>}<br><br>Please note that<br>1) Thread sleep doesn’t lose any monitors or locks current thread has acquired.<br>2) Any other thread can interrupt the current thread in sleep, in that case InterruptedException is thrown.<br></p></div><hr color='#eee'>
</div><div class="question">26. What is static synchronization of threads.</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >When synchronizing on a static method , the monitor belongs to the class. <br> That means while execution of a static method the whole class is blocked. So other static synchronized methods are also blocked. If one thread is executing a static synchronized method, all other threads trying to execute any static synchronized methods will be blocked.<br></p></div><hr color='#eee'>
</div><div class="question">27. Create two thread classes - one which implements Runnable interface and the other which extends Thread class. First thread must continuosly print values from 1 to 100 and second thread must print values continuously from -1 to -100.</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >class NumThread extends Thread{<br>     public void run(){<br>         for(int i=0;i&lt;100;i++){<br>             System.out.println(""+(i+1));<br>             try {<br>                 Thread.sleep(1000);<br>             } catch (InterruptedException e) {<br>                 e.printStackTrace();<br>             }<br>         }<br>     }<br>}<br>class NumThread2 implements Runnable {<br>    public void run(){<br>        for(int i=-1;i&gt;-100;i--){<br>            System.out.println(i);<br>            try {<br>                Thread.sleep(1000);<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br>        }<br>    }<br>}<br><br>public class TwoThreads {<br>    public static void main(String args[]){<br>        NumThread nth = new NumThread();<br>        nth.start();<br>        Thread ath = new Thread(new NumThread2());<br>        ath.start();<br>    }<br>}<br></p></div><hr color='#eee'>
</div><div class="question">28. What Is the Thread’s Interrupt Flag? How Can You Set and Check It? How Does It Relate to the Interruptedexception?</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >The interrupt mechanism is implemented using an internal flag known as the interrupt status. Invoking Thread.interrupt sets this flag. When a thread checks for an interrupt by invoking the static method Thread.interrupted, interrupt status is cleared. The non-static isInterrupted method, which is used by one thread to query the interrupt status of another, does not change the interrupt status flag.<br><br>By convention, any method that exits by throwing an InterruptedException clears interrupt status when it does so. However, it's always possible that interrupt status will immediately be set again, by another thread invoking interrupt.</p></div><hr color='#eee'>
</div><div class="question">29. What are atomic operations?</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >In programming, an atomic action is one that effectively happens all at once. An atomic action cannot stop in the middle: it either happens completely, or it doesn't happen at all. No side effects of an atomic action are visible until the action is complete.<br><br>Atomic actions cannot be interleaved, so they can be used without fear of thread interference. <br><br>If a thread performs a non-atomic operation on  an object which is shared by other objects, there will be inconsistency in the state of that object. To avoid that, we need to use synchronization. </p></div><hr color='#eee'>
</div><div class="question">30. What does synchronized mean for a method, for a block and for a static method?</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >The synchronized keyword before a block means that any thread entering this block has to acquire the lock.  If the lok is already acquired by another thread, the former thread will enter the BLOCKED state and wait until the lock is released.<br><br>synchronized(object) {<br>    // ...<br>}<br><br>A synchronized  method has the same semantics, but the instance itself acts as a lock object.<br><br>synchronized void instanceMethod() {<br>    // ...<br>}<br><br>For a static synchronized method, the lock is the Class object representing the declaring class.<br><br>static synchronized void staticMethod() {<br>    // ...<br>}</p></div><hr color='#eee'>
</div><div class="question">31. If two threads from different objects of the same class call a synchronized method, will one of them gets blocked?</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >No</p></div><hr color='#eee'>
</div><div class="question">32. Explain wait, notify and notifyall methods in Object class.</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >These 3 methods defined in Object class are used for thread synchronization.<br><br>wait() method pauses the current thread and waits for some other thread to invoke notify() or notifyAll() method.<br><br>The thread must own the monitor of this object.<br><br>wait() has two other variants<br>wait(long millisecs)<br>wait(long millisecs,long nanosecs)<br><br>These two variants will resume the thread after the given time has elapsed if no other thread invokes notify.<br><br>notify() : Wakes up a single thread that is waiting on this object's monitor.The choice is arbitrary.<br><br>notifyAll : Wakes up all threads that are waiting on this object's monitor. A thread waits on an object's monitor by calling one of the wait methods.<br><br>The awakened threads will not be able to proceed until the current thread relinquishes the lock on this object. The awakened threads will compete in the usual manner with any other threads that might be actively competing to synchronize on this object;<br><br></p></div><hr color='#eee'>
</div><div class="question">33. What is a deadlock? What is a livelock? And what is starvation?</p>
<pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'>
	<p >In concurrent computing, a deadlock is a state in which each member of a group of actions,
	 is waiting for some other member to release a lock<br><br>A livelock is similar to a deadlock, 
	 except that the states of the processes involved in the livelock constantly change with regard to one another, 
	 none progressing. Livelock is a special case of resource starvation; the general definition only states that a specific process 
	 is not progressing.<br><br>A real-world example of livelock occurs when two people meet in a narrow corridor, and each tries 
	 to be polite by moving aside to let the other pass, but they end up swaying from side to side without making any progress because 
	 they both repeatedly move the same way at the same time.<br><br> 
	 <br>Starvation is a situation in which a runnable process is overlooked indefinitely
	  by the scheduler; although it is able to proceed, it is never chosen.</p></div></div>
	  
	  
	  <script > init();</script>
	  </body>
	  </html>
