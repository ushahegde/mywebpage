<html><head><meta charset='utf-8' /><title></title><style>.accordion {  background-color: #eee;  color: #444;  cursor: pointer;  padding: 10px;  width: auto;  border:none;  text-align: left;  outline: none;  font-size: 15px;  transition: 0.4s;}.active, .accordion:hover {  background-color: #ccc; }.panel {  padding: 0 18px;  display: none;  background-color: #ddd;  overflow: hidden;}</style></head><body  ><h1> Java Questions on INHERITANCE</h1><hr color='#eee'>
<p>What is an interface in Java?</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >Interface is a group of methods with empty body. A class implementing an interface has to define these methods.<br><br>e.g.<br>OnClickListener is an interface with a method onClick()<br><br>interface OnClickListener(){<br>     public void onClick();<br>}<br><br>Now any class which defines this interface has to define onClick() method.<br><br>class MyClass implements OnClickListener{<br>   ....<br>   public void onClick()<br>   {<br>      ....<br>   }<br>}</p></div><hr color='#eee'>
<p>What are overloading and overriding?</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >When multiple methods in the same class have same name but different type/number of parameters, the methods are said to be overloaded.<br><br>When a method of a base class is redefined in a derived class with same signature, it is said to be overriding the base class method.<br><br>e.g.<br>class A{<br>   int sum(int a,int b){.....}<br>   float sum(float a,float b){....}<br>   int sum(int a,int b,int c, int d){....}<br>}<br><br> <br>class A{<br>    void print(int a){.....}<br>}<br>class B extends A{<br>    void print(int a){.....}<br>}<br></p></div><hr color='#eee'>
<p>Can you override final methods?</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >No. Final methods can not be overridden. By defining a method as final, subclasses can not override that method.<br><br>It is advisable to make the methods called by constructor as final. </p></div><hr color='#eee'>
<p>What is an abstract class? How does it differ from an interface?</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >An abstract class is a class which can not be instantiated - no objects can be created from an abstract class. An abstract class is defined with keyword abstract. <br><br>But a sub-class of an abstract can be instantiated. <br><br>An abstract class can have fields, methods. The methods can be abstract or non-abstract. <br><br>e.g.<br><br>abstract class Vehicle{<br>     int speed;<br>     void start(){}<br>     abstract void accelerate();<br>}<br><br>If you define an abstract method in a class, then the class must be declared as abstract. Otherwise you will get a syntax error.<br><br>An interface can only have final fields and abstract methods. No method in an interface can have an implementation. And an interface can have only final, static, public fields. <br><br>A class can extend one abstract class. But a class can implement multiple interfaces. </p></div><hr color='#eee'>
<p>What is inheritance? Explain with an example.</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >Inheritance is the process of creating new classes extending existing classes. The new class is called sub-class or derived class and the original class is called base class. <br>The inherited class inherits all the methods and fields of the base class. It can also its own members.<br><br>Every object of a derived class is an object of base class.<br><br></p></div><hr color='#eee'>
<p>With an example explain the keyword super. </p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >super keyword is used to call the super class method.<br><br>When a method is overridden by a derived class, the base class method is hidden. To call the base class method, we have to use super. followed by method name.<br><br>e.g.<br>class B1{<br>   void print(){<br>      System.out.println("B1");<br>   }<br>}<br>class D1 extends B1{<br>    void print(){<br>       System.out.println("D1");<br>       super.print();<br>   }<br>}<br>class Test{<br>   public static void main(String args[]){<br>      D1 obj = new D1();<br>      obj.print();<br>  }<br>}<br><br>Now print() method in D1 class calls the super class print method.<br><br>Output of the program<br>D1<br>B1<br><br>super keyword is also used to call the super class constructor in a derived class constructor. <br><br>super() call in a constructor must be first statement of the constructor.<br><br>class B1{<br>    B1(){<br>      System.out.println("Constructor of B1");<br>    }<br>}<br>class D1 extends B1{<br>    D1(){<br>      super();<br>      System.out.println("Constructor of D1");<br>   }<br>}<br><br>Now if we create an object of D1 class, then it will call D1 constructor which also calls B1 constructor. <br><br>If we do not explicitly call super class constructor, compiler implicitly calls super class constuctor always. (which calls its super class constructor and so on. It is called constructor chaining. )<br><br></p></div><hr color='#eee'>
<p>Which is the base class in Java for all other classes</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >Object is the base class of all other classes in Java.<br><br>All classes in Java are either directly or indirectly derived from Object class.<br><br>Object class provides the following methods - toString(), equals(),  hashCode(), finalize, clone() and getClass() methods. </p></div><hr color='#eee'>
<p>What is final class?</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >A class which can not be subclassed is a final class. A class is made final by add the keyword final to the definition of the class. <br><br>final class A{<br>    int m;<br>  }<br>class B extends A{<br>..<br>}<br><br>Defintion of class B gives an error. <br><br>e.g.<br>String library class is a final class. </p></div><hr color='#eee'>
<p>Write a program with an interface which has a method to find perimeter. Write two classes circle and rectangle which implement this interface
</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><pre class='courier'>interface Calc{ 
    public int findPerimeter();
}
class Circle implements Calc{
    int radius;
    final double PI=22.0/7;
    Circle(int n){
      radius=n;
    }
    public int findPerimeter(){
       return (int)(2*PI*radius);
    }
}
class Rectangle implements Calc{
   int len,wid;
   Rectangle(int l,int w){
      len=l;
      wid = w;
   }
   public int findPerimeter(){
      return 2*(len+wid);
   }
}

class Demo{
     public static void main(String args[]){
          Circle c = new Circle(7);
          Rectangle r = new Rectangle(10,5);
          System.out.println("Perimeter of circle is "+c.findPerimeter());
          System.out.println("Perimeter of rectangle is "+r.findPerimeter());
    }
}</pre></div><hr color='#eee'>
<p>How do you inherit from a class in Java? </p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >A class is inherited by using the keyword extends. <br><br>e.g.<br>class B extends A{<br>   /****<br>}<br><br>A class can inherit only from one super class. <br><br>The inherited class inherits all the instance members of the super class. The sub class can access all the default, public and protected members of super class. But it can not access the private members of the super class. </p></div><hr color='#eee'>
<p>What is method overriding? What are the rules for overridden methods?</p><pre class='courier'> 
</pre><button class='accordion'>Answer</button><div class='panel'><p >Overriding a method is redefining a super class method in the sub class. <br><br>The overriding method must have the exact same signature as the super class method. </p></div><hr color='#eee'>
<p>Is it possible to override a static method in Java?</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >No. It is not possible to override a static method. If we write a static method in subclass with the same signature as super class, then the super class method is hidden. And more importantly there is no late binding or polymorphism.<br><br>class A{<br>     int n;<br>     void print(){<br>      System.out.println(" n is"+n);<br>    }<br>    static void printHello(){<br>       System.out.println("Hello coder!!");<br>   }<br>}<br>class B extends A{<br>     static void printHello(){<br>         System.out.println("Hello Java");<br>     }<br>}<br>class Test{<br>    public static void main(String args[]){<br>         B obj = new B();<br>         obj.print();<br>         obj.printHello();<br>   }<br>}<br><br>Output is<br> n is0<br>Hello Java<br><br>Here we are not able to call the base class printHello() method as it is hidden.<br><br><br>         </p></div><hr color='#eee'>
<p>Can an interface extend another interface? Can an interface extend multiple interfaces?</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >Yes. An interface can extend one or more interfaces.<br><br>interface car extends vehicle, fourwheeler{<br>/****/<br>}</p></div><hr color='#eee'>
<p>Write a program with an interface compute with two methods add and subtract. Define PI as constant member of this interface. Write a class which implements this interface </p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><pre class='courier'>import java.util.Scanner;

interface Compute{
    int add(int a,int b);
    int subtract(int a,int b);
    double PI=(double)22/7;
}
public class InterfaceTest implements Compute{
    public int add(int a, int b) {
        return a+b;
    }

    public int subtract(int a, int b) {
        return a-b;
    }
    public static void main(String args[]){
        int m,n;
        InterfaceTest obj = new InterfaceTest();
        Scanner scanner = new Scanner(System.in);
        System.out.println("Enter two numbers");
        m = scanner.nextInt();
        n = scanner.nextInt();
        System.out.println("The sum is "+obj.add(m,n));
        System.out.println("Enter radius of circle");
        int r = scanner.nextInt();
        System.out.println("The area of circle is "+obj.PI*r*r);
    }
}
</pre></div><hr color='#eee'>
<p>What are default methods? How do you define them?</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >Methods declared in an interface with the keyword default are default methods. Such methods must have implementation.<br><br> Normal methods in an interface do not have implementation and are abstract. Default methods are not abstract. <br><br>e.g.<br>interface MyInterface{<br>     void aMethod();<br>     default void defMethod(){<br>        System.out.println("Hello user");<br>    }<br>}</p></div><hr color='#eee'>
<p>Write a class TwoWheeler which in inherited from class Vehicle. </p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><pre class='courier'>class Vehicle{
     int speed;
     void start(){}
     void stop(){}
}
class TwoWheeler extends Vehicle{}

public class Demo{
   public static void main(String args[]){
       TwoWheeler t = new TwoWheeler;
       t.speed = 40;
       t.start();
  }
}

The TwoWheeler class has inherited all fields and methods of Vehicle class.</pre></div><hr color='#eee'>
<p>Which of the following lines of code will produce syntax error? Why?</p><pre class='courier'>class A{
   int num1;
}
class B extends A{
   int num2;
}
class Demo{
    public static void main(String args[]){
          A a1 = new A();
          B b1 = new B();
          b1.num1 = 10;//line 1
          b1.num2 = 20;//line 2
          a1.num1 = 5;//line 3
          a1.num2 = 15;//line 4
          a1 = new B();//line 5
          b1 = new A();//line 6
    }
}</pre><button class='accordion'>Answer</button><div class='panel'><p >Lines 4 and 6 produce error.<br><br>b1 is an object of class B. B class has two fields - num1 which is inherited from A class and num2 which is a field from B class. b1 can access both of them. <br><br>If num1 was a private field, then b1 will not be able to access num1. But as there is no access speicifer - num1 is having default access - which means it is accessible in the package where it is defined. <br><br>But a1 is an object of A class. And as A class is a super class object, it has only one field num1. It does not have the field num2. So line 4 produces error.<br><br>A derived class object can be assigned to a base class object. But the reverse is not true.<br><br>Any object of B class is also an object of A class. But an object of A class is not an object of B class. </p></div><hr color='#eee'>
<p>Explain final classes with an example.</p><pre class='courier'></pre><button class='accordion'>Answer</button><div class='panel'><p >If a class is defined as final, it can not be extended. Final classes are useful in creating immutable classes - String library class is a final class. <br><br>If you extend a final class, you will get a syntax error.<br><br>e.g.<br>final class A{<br>   int n;<br>    void print(){<br>        System.out.println("Hello world");<br>    }<br>}<br>class B extends A{//syntax error<br>   int m;<br>}</p></div><script >var acc = document.getElementsByClassName("accordion");var i;for (i = 0; i < acc.length; i++) {  acc[i].addEventListener("click", function() {    /* Toggle between adding and removing the active class,    to highlight the button that controls the panel */    this.classList.toggle("active");    /* Toggle between hiding and showing the active panel */    var panel = this.nextElementSibling;    if (panel.style.display === "block") {      panel.style.display = "none";    } else {      panel.style.display = "block";    }  });} </script></body></html>